{"meta":{"title":"chl'blog","subtitle":"welcome","description":"本站内容仅用于自己日常学习记录，不做商业用途","author":"chl","url":"https://chl-git.github.io","root":"/"},"pages":[{"title":"about","date":"2021-03-17T14:43:09.963Z","updated":"2021-03-17T14:43:09.963Z","comments":true,"path":"about/index.html","permalink":"https://chl-git.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-03-14T13:58:46.292Z","updated":"2021-03-14T13:58:46.292Z","comments":true,"path":"categories/index.html","permalink":"https://chl-git.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2021-04-04T13:09:38.000Z","updated":"2021-06-15T12:27:24.148Z","comments":true,"path":"404/index.html","permalink":"https://chl-git.github.io/404/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-03-14T14:00:16.539Z","updated":"2021-03-14T14:00:16.539Z","comments":true,"path":"tags/index.html","permalink":"https://chl-git.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"04_寻找两个正序数组的中位数","slug":"04-寻找两个正序数组的中位数","date":"2021-09-16T13:39:01.000Z","updated":"2021-09-16T14:44:14.679Z","comments":true,"path":"posts/639f29fb/","link":"","permalink":"https://chl-git.github.io/posts/639f29fb/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://chl-git.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://chl-git.github.io/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://chl-git.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://chl-git.github.io/tags/leetcode/"}]},{"title":"hexo","slug":"hexo设置","date":"2021-06-15T12:47:45.000Z","updated":"2021-06-15T14:48:10.269Z","comments":true,"path":"posts/310047be/","link":"","permalink":"https://chl-git.github.io/posts/310047be/","excerpt":"","text":"引用&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125; Every interaction is both precious and an opportunity to delight. &#123;% endblockquote %&#125; > Every interaction is both precious and an opportunity to delight. **Seth Godin** — [*Welcome to Island Marketing*](http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html) Every interaction is both precious and an opportunity to delight. Seth Godin Welcome to Island Marketing Every interaction is both precious and an opportunity to delight.Seth Godin — Welcome to Island Marketing 插入YouTube视频（是可以直接播放的）&#123;% youtube lJIrF4YjHfQ %&#125; &#123;% youtube PL9hW1uS6HUfscJ9DHkOSoOX45MjXduUxo 'playlist' %&#125; 隐私模式&#123;% youtube lJIrF4YjHfQ false %&#125; # 添加false参数 &#123;% youtube PL9hW1uS6HUfscJ9DHkOSoOX45MjXduUxo 'playlist' false %&#125; 插入Vimeo视频&#123;% vimeo video_id %&#125; 引用其他文章&#123;% post_link filename [title] [escape] %&#125;[]() &#123;% post_link Corda-API-Flows %&#125; # 找的是绝对路径 &#123;% post_link Corda-API-Flows 别名 %&#125; [Corda-API-Flows](aa15b6d6.html) [别名](Corda-API-Flows) Corda-API-Flows 别名 Corda-API-Flows别名","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chl-git.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://chl-git.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://chl-git.github.io/tags/markdown/"}]},{"title":"javaSE","slug":"javaSE","date":"2021-06-15T10:52:31.000Z","updated":"2021-06-16T09:32:18.337Z","comments":true,"path":"posts/2c9e36bd/","link":"","permalink":"https://chl-git.github.io/posts/2c9e36bd/","excerpt":"","text":"变量命名规则 所有变量、方法、类名：见名知意 类成员变量、局部变量、方法名：首字母小写加驼峰规则 常量：大写字母和下划线 类名：首字母大写加驼峰规则 基本数据类型// 八进制 int a1 = 010; // a1=8 // 十六进制 int a2 = 0x10; //a2 = 16 // 二进制 int a3 = 0b10; //a3 = 2 System.out.println(10_000_000); //10000000 important：不要使用浮点数进行比较，有误差 // 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。 ？？？ float i1 = .1f; double d1 = .1; System.out.println(i1==d1); // false float i1 = 465464564654564645f; float i2 = i1+1; System.out.println(i2==i1); // true char c1 = 'm'; char c2 = '中'; System.out.println((int)c1); // 强制转换 109(unicode编码) System.out.println((int)c2); // 20013 System.out.println('\\u0109'); // a u0000-uFFFF 字符串String a = new String(\"a\"); String b = new String(\"a\"); System.out.println(a.equals(b) ); //true System.out.println(a==b); //false String c = \"a\"; String d = \"a\"; System.out.println(c == d); //true System.out.println(c.equals(d) ); //true int a = 1000000000; int b = 200; System.out.println(a*b); // 溢出 System.out.println(a*(long)b); // 转换b，结果变成long。 System.out.println((long)a*b); // ******转换的是a，结果是long。不会溢出 System.out.println((long)(a*b)); // 是对（a*b）转换，溢出 int c = 400; System.out.println((b/c)); // 0 System.out.println((double)b/c); // 或者b/(double)c 结果才是 0.5 对象没有初始化的时候会设置为默认值； byte、int、short、long: 0 char: &#39;\\u0000&#39;对应的字符 float、double: 0.0 boolean: false 其他非基本数据类型会设为null public class A&#123; String name; int age; public static void main(String[] args)&#123; A a = new A(); System.out.print(a.name) // null System.out.print(a.age) // 0 &#125; &#125; 修饰符final使用final关键词修饰的变量一经初始化就不能更改 final int a = 1; staticstatic 用于类成员变量 public class A&#123; static String name; static int age; public static void function&#123; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://chl-git.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chl-git.github.io/tags/java/"},{"name":"javaSE","slug":"javaSE","permalink":"https://chl-git.github.io/tags/javaSE/"}]},{"title":"Gradle-learning","slug":"Gradle-learning","date":"2021-05-12T13:44:40.000Z","updated":"2021-06-15T14:18:16.158Z","comments":true,"path":"posts/c1808150/","link":"","permalink":"https://chl-git.github.io/posts/c1808150/","excerpt":"","text":"配置文件解释build.gradle对当前项目做局部配置 plugins &#123; &#x2F;&#x2F; 项目中声明了哪些插件 id &#39;java&#39; &#x2F;&#x2F; id 表示项目中要使用哪个插件，调用所有的java相关插件 &#x2F;&#x2F; id &#39;kotlin&#39; &#125; 项目组织以及版本号 &#x2F;&#x2F; 项目名称在settings.gradle group &#39;org.example&#39; &#x2F;&#x2F; 组织名 version &#39;1.0-SNAPSHOT&#39; &#x2F;&#x2F; 版本号 &quot;SNAPSHOT&quot;表示快照版本，&quot;RELEASED&quot;表示稳定版 repositories &#123; &#x2F;&#x2F; 下载的文件放置在.gradle文件下 mavenCentral() &#125; 依赖管理,可以在maven中心仓库查看依赖怎么写。格式为scope group:name:version testRuntimeOnly称为Scope complie 表示编译、运行可用，打包时也会加入 testRuntimeOnly 表示运行测试时可用 providedCompile 仅在当前环境可用 dependencies &#123; testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.7.0&#39; testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.7.0&#39; &#125; test &#123; useJUnitPlatform() &#125; settings.gradle全局配置 rootProject.name &#x3D; &#39;gradleDemo&#39;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"https://chl-git.github.io/categories/Gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://chl-git.github.io/tags/gradle/"},{"name":"依赖管理","slug":"依赖管理","permalink":"https://chl-git.github.io/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}]},{"title":"Groovy语言学习","slug":"Groovy语言学习","date":"2021-05-12T12:31:12.000Z","updated":"2021-06-15T14:18:19.891Z","comments":true,"path":"posts/e90fdfca/","link":"","permalink":"https://chl-git.github.io/posts/e90fdfca/","excerpt":"","text":"基本语法print,println,printf//打印 println(1) print(1) println() //可以不加括号 println \"hello\" 定义变量//强类型 int a = 5 //弱类型。会根据赋值自动解析数据类型 def a = 5 println(a.class) //class java.lang.Integer 方法定义//定义方法 def test(def a,def b)&#123; println(a+b) &#125; test(5,6) // 11 test(\"5\",\"6\")// '56' test(\"5\",6) //'56' def test2(def a)&#123; def b = a? 'true':'false' println(b) &#125; test2(true) // true test2(10) //true test2(\"\") //false test2(\"10\") //true list和map定义map使用的是[]不是&#123;&#125; 使用for(i in map)这里的i是key:value //列表的定义 def list = [\"1\",\"2\"] //遍历 for (i in list)&#123; println(i) &#125; // 1 2 for (j in [0,1])&#123; println(list[j]) //list[i] 取值 &#125; // 1 2 //定义map集合 def map = [\"Chinese\":50,\"Math\":25] println(map) //[\"Chinese\":50,\"Math\":25] println(map.keySet()) // [Chinese, Math] println(map.values()) // [50,25] println(map.Chinese) // 50 println(map.get(\"Chinese\")) //50 for (i in map)&#123; println(i) //Chinese=50 Math=25 &#125; 闭包需要使用Closure类，但是不用导入（import） // 没有参数的闭包 def co1 = &#123; print(\"hello \") &#125; def co2 = &#123; println(\"world\") &#125; def testCo(Closure closure1,Closure closure2)&#123; closure1(); closure2(); &#125; testCo(co1,co2) // hello world // 有参数的闭包 def closure = &#123; String v-> // 参数类型可以不指定，直接写个 v println(v.length()) for(i in v)&#123; print(i+\",\") &#125; &#125; static def testCo(Closure closure)&#123; closure('hello'); &#125; testCo(closure) // 5 // h,e,l,l,o,","categories":[{"name":"Groovy","slug":"Groovy","permalink":"https://chl-git.github.io/categories/Groovy/"}],"tags":[{"name":"Groovy","slug":"Groovy","permalink":"https://chl-git.github.io/tags/Groovy/"}]},{"title":"Corda（5）——Accounts","slug":"Corda（5）——Accounts","date":"2021-05-01T16:32:16.000Z","updated":"2021-06-15T14:34:39.078Z","comments":true,"path":"posts/4327cc6a/","link":"","permalink":"https://chl-git.github.io/posts/4327cc6a/","excerpt":"","text":"这一部分后面补上","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"Accouts","slug":"Accouts","permalink":"https://chl-git.github.io/tags/Accouts/"}]},{"title":"Corda记录","slug":"Corda记录","date":"2021-04-18T09:01:41.000Z","updated":"2021-06-15T14:19:13.759Z","comments":true,"path":"posts/f5a1c04b/","link":"","permalink":"https://chl-git.github.io/posts/f5a1c04b/","excerpt":"","text":"UTXO模型考虑的问题 怎么满足的用户的隐私要求 不同机构之间的数据怎进行联邦学习 监管怎么考虑：这个只是对于监管提供了部分数据的接口 使用Corda的优缺点： need-to-know 交易记录不公开，只需要记录自己参与的，保障隐私的同时，进一步减少需要存储的交易数量。 为什么银行会有你的交易记录？？？ 如果没有怎么监管，或者说你监管的是什么。 只是监管账号的发行？ 银行为什么给你发货币。 Corda智能合约定义：一组数据以及一个参与方被允许对这些数据执行的操作组成。（states and contracts） 合约定义了什么可以做而不是什么不可以做。除了里面定义的不能做的事，其他都可以做。所以在设计时就需要考虑足够的参与方交易行为的约束。 节点需要对state本身进行检验，以保证交易合法 Flow对于同一个节点的账户，要执行转账操作（MoveFungibleTokenFlow），这个flow只能在保存该账户资产的节点上进行调用，因为这个flow没有识别身份的参数，在使用过程中会默认把执行流操作的节点作为该账户资产的拥有者，然后在本地查找需要转出的资金的账户信息，这将导致错误。 流执行是要求可以进行断点记录的，就是交易对方（counterParty）或者是公证人如果没有上线，收集签名的时候需要等待对方上线执行，主要是用在不同节点的交易记录。 交易限制基本的匿名账户的限额问题， 限制单次转出的金额。 这个可以在合约里面进行验证，匿名账户和完成身份信息认证的账户有自己身份标识 限制转入转出次数， 银行作为托管账户，是可以知道交易双方的基本信息的，（因为需根据匿名性的需要，我们可以在每次交易时都生成一个publickey，因为账户在网络层面是不可见的，一方收到签名只会以为是对方节点Node换了个key进行签名） 但是对于交易的金额是不能够知道的，这一部分具体实现是怎么做到的，需要考虑一下。 我可以在数据库中实时更新账户的转入转出次数，当达到限定次数之后。 解决方案：场景1：一个人注册多个匿名账号的数据信息 银行不应该有以下数据信息： 不同账户数据之间的关联信息 交易详细的数据记录，场景中主要是交易的金额。这里有一个问题是为什么会记录用户账户的记录，可不可以直接对整个交易内容全部进行加密进行加密。个人如果对全部的信息进行加密，那么在进行账户交易次数的验证的时候，银行本身进行数据的查询是没有可行性的。 后面研究方向私钥管理，托管账户的节点会保存所有账户每次申请的私钥，后面处理第三方数据 联邦学习实现不同机构间的数据进行建模，消除第三方机构。 系统监管或者说验证的时间间隔，也就是每天进行记录的检验还是其他的给定的数据验证的间隔时间。 多银行之间的数据如何进行有效的校对、验证和监管。据悉，现今意大利各地银行都在使用R3的Corda区块链用以加快对交易记录的双重检查。意大利银行协会负责人表示，银行间对账流程与数据交换基础技术都必须改变。在旧的银行系统中需要花费30至50天的对账，在Corda上一天之内就能完成。 //Buyer Query for token balance. QueryCriteria queryCriteria = QueryUtilities.heldTokenAmountCriteria(this.getInstance(currency), senderAccount).and(QueryUtilities.sumTokenCriteria()); List&lt;Object> sum = getServiceHub().getVaultService().queryBy(FungibleToken.class, queryCriteria).component5(); if(sum.size() == 0) throw new FlowException(senderAccountName + \" has 0 token balance. Please ask the Bank to issue some cash.\"); else &#123; Long tokenBalance = (Long) sum.get(0); if(tokenBalance &lt; this.amount) throw new FlowException(\"Available token balance of \" + senderAccountName + \" is less than the cost of the ticket. Please ask the Bank to issue some cash if you wish to buy the ticket \"); &#125; SignedTransaction moveTokensTx = subFlow(new MoveFungibleTokens( Collections.singletonList(partyAndAmount), Collections.emptyList(), heldByMint, mint)); // Persist token-transaction. PersistentTokenTransaction tokenTransaction = new PersistentTokenTransaction( new UniqueIdentifier().getId().toString(), moveTokensTx.getId().toString(), Instant.now(), \"MOVE\", \"Mint\", \"HolderA\", 100); getServiceHub().withEntityManager(entityManager -> &#123; entityManager.persist(tokenTransaction); return null; &#125;);","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"UTXO模型","slug":"UTXO模型","permalink":"https://chl-git.github.io/tags/UTXO%E6%A8%A1%E5%9E%8B/"}]},{"title":"连接非同一网段的另一台主机上的虚拟机","slug":"连接非同一网段的另一台主机上的虚拟机","date":"2021-04-12T10:53:26.000Z","updated":"2021-06-15T15:00:33.676Z","comments":true,"path":"posts/d508ea0d/","link":"","permalink":"https://chl-git.github.io/posts/d508ea0d/","excerpt":"","text":"安装在远程机器B上安装vmware以及虚拟机C（linux、centos等）。 说明: 本地机器称为A（windows10） 远程机器称为B（windows10） 远程机器上的虚拟机称为C（centos7） 配置虚拟机网络配置选择NAT模式，进入虚拟机查看是否可以上网：ping baidu.com； [root@localhost ~]# cd /etc/sysconfig/network-scripts/ #网络配置文件路径 [root@localhost network-scripts]# ls ifcfg-ens33 ifdown-isdn ifup ifup-plip ifup-tunnel ifcfg-lo ifdown-post ifup-aliases ifup-plusb ifup-wireless ifdown ifdown-ppp ifup-bnep ifup-post init.ipv6-global ifdown-bnep ifdown-routes ifup-eth ifup-ppp network-functions ifdown-eth ifdown-sit ifup-ib ifup-routes network-functions-ipv6 ifdown-ib ifdown-Team ifup-ippp ifup-sit ifdown-ippp ifdown-TeamPort ifup-ipv6 ifup-Team ifdown-ipv6 ifdown-tunnel ifup-isdn ifup-TeamPort # 更改ifcfg-ens33（可能名字会有所不同，但基本是这个）把值改为yes: [root@localhost network-scripts]# vi ifcfg-ens33 TYPE=Ethernet #网络类型 BOOTPROTO=dhcp #IP获取方式，有dhcp自动获取和静态IP（none/static） NAME=ens33 #网络名称 UUID=d1755a41-8026-42f1-871d-9cd78fa2aa3c DEVICE=ens33 #驱动名称 ONBOOT=yes #设置开机启动 然后保存退出，重启网络:systemctl restart network.service;再ping baidu.com查看是否成功。 配置B与C的映射打开C，输入ifconfig（可能需要先安装一下yum install net-tools.x86_64），查看ip地址： 打开主机B的vmware，点击编辑-&gt;虚拟网络编辑器： 在弹出的界面点击更改设置: 选中VMnet8，在下面选择NAT模式并点击设置： 填入一下信息： 主机端口：随便写一个，但是不能使用本机B已经占用的端口，可以考虑大一点的数字，比如（10101，要记住）； 类型选择tcp 虚拟机IP地址：输入上面查到虚拟机c的ip 虚拟机端口：22（可能有的不一样，可以使用service sshd status查询） 打开B的防火墙配置，点击高级设置： 添加入站规则–&gt;新建规则–&gt;要创建的入站规则（选择端口）–&gt;选择tcp–&gt;选择特定本地端口（选择上面写的10101），然后一直点击下一步，最后输入名称和描述，点击完成即可。 使用xshell连接要注意的是主机和端口是主机B的ip（自己查ipconfig）和端口号（10101）。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/tags/Linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://chl-git.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"网络配置","slug":"网络配置","permalink":"https://chl-git.github.io/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"name":"防火墙","slug":"防火墙","permalink":"https://chl-git.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"Centos7-Fate环境配置","slug":"Centos7-Fate环境配置","date":"2021-04-09T11:57:33.000Z","updated":"2021-06-15T14:17:05.411Z","comments":true,"path":"posts/499c0a40/","link":"","permalink":"https://chl-git.github.io/posts/499c0a40/","excerpt":"","text":"手动安装OS：Centos7安装时需要注意网络配置 安装时的版本信息请参考FATE.env Python3.6.5安装Python3.6的相关依赖包:yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 安装wget，gccgcc是一个编译器 yum install wget gcc 安装Python3.6.5# 下载对应版本的压缩包 wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.6.5&#x2F;Python-3.6.5.tgz # 解压文件 tar -xzvf Python-3.6.5.tgz -C &#x2F;usr&#x2F;local # 进入&#x2F;usr&#x2F;local&#x2F;Python-3.6.5，并编译 cd &#x2F;usr&#x2F;local&#x2F;Python-3.6.5 .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 make &amp;&amp; make install ./configure生成Makefile，make是编译的意思，就是把源码包编译成二进制可执行文件，make install 就是安装的意思。 安装完成以后可以删除安装包，即/usr/local/Python-3.6.5文件夹。 更换系统默认Python版本原来的系统默认使用的是python2.7 看一下/usr/bin路径下的python，命令：ll： 里面的python可能本身就是一个链接，如果是的话需要先删除：rm -rf python，然后创建新的软链接。 python是一个文件，使用命令：mv python python2(或者python2.7)，再创建软链接。 创建软链接的命令： ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3.6 &#x2F;usr&#x2F;bin&#x2F;python ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip 创建完成后可以输入python -V和pip -V查看是否安装成功。 查看yum命令是否正常使用（应该是会报错的），一次打开文件下面两个文件，将两个文件第一行代码都改为#!/usr/bin/python2是之前将原来的python改后的路径！！！ [root@localhost &#x2F;]# vim &#x2F;usr&#x2F;bin&#x2F;yum #!&#x2F;usr&#x2F;bin&#x2F;python import sys [root@localhost &#x2F;]# vim &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down #! &#x2F;usr&#x2F;bin&#x2F;python 使用pip安装virtualenv和virtualenvwrapper可以修改pip的安装源，改成国内的源 # 使用命令创建并进入家(不是home)目录下的&#96;.pip&#96;文件夹。 mkdir ~&#x2F;.pip &amp;&amp;cd ~&#x2F;.pip # 创建这个文件 vim pip.conf 添加一下内容： [global] timeout = 6000 index-url = http://pypi.mirrors.ustc.edu.cn/simple/ extra-index-url = http://mirrors.aliyun.com/pypi/simple/ http://pypi.tsinghua.edu.cn/simple/ http://pypi.org [install] trusted-host = pypi.mirrors.ustc.edu.cn mirrors.aliyun.com pypi.tsinghua.edu.cn pypi.org windows类似，也是在用户的路径下创建文件夹.pip，在里面创建pip/conf文件，内容同上。 pip install virtualenv virtualenvwrapper 找到如下文件： [root@localhost bin]# find &#x2F; -name virtualenvwrapper.sh &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;virtualenvwrapper.sh 编辑配置文件 vim ~&#x2F;.bashrc 添加如下命令 export WORK_NAME&#x3D;~&#x2F;.virtualenvs export VIRTUALENVWRAPPER_VIRTUALENV&#x3D;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;virtualenv source &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;virtualenvwrapper.sh 保存配置： [root@localhost bin]# source ~&#x2F;.bashrc virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;premkproject virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;postmkproject virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;initialize virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;premkvirtualenv virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;postmkvirtualenv virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;prermvirtualenv virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;postrmvirtualenv virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;predeactivate virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;postdeactivate virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;preactivate virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;postactivate virtualenvwrapper.user_scripts creating &#x2F;root&#x2F;.virtualenvs&#x2F;get_env_details 安装jdk使用java -version查看本地有关java信息 使用rpm -qa|grep java命令查看安装包位置 [root@localhost bin]# rpm -qa|grep java java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64 java-1.8.0-openjdk-headless-1.8.0.282.b08-1.el7_9.x86_64 删除上面两个文件： rpm -e --nodeps java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64 rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.282.b08-1.el7_9.x86_64 再次输入java就会报错。 下载jdk1.8，最好是本地下载之后上传，保存到/usr/local路径下，并解压 [root@localhost local]# tar -zxvf jdk-1.8.tar.gz [root@localhost local]# mv jdk1.8.0_281 jdk8 [root@localhost local]# ls bin etc games include jdk8 jdk-1.8.tar.gz lib lib64 libexec python3 python-3.6.5 sbin share src 配置环境： vim &#x2F;etc&#x2F;profile # 在最后添加如下内容 export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8 # 你的路径 export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;toos&#x2F;jar export PATH&#x3D;$PATH:$&#123;JAVA_HOME&#125;&#x2F;bin # 检查 [root@localhost jdk8]# java -version java version &quot;1.8.0_281&quot; Java(TM) SE Runtime Environment (build 1.8.0_281-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode) 直接使用Docker安装安装docker删除旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 设置仓库地址安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。 yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加阿里云镜像仓库地址： sudo yum-config-manager \\ --add-repo \\ http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo 这里可能会有报错： [root@localhost ~]# yum-config-manager \\ &gt; --add-repo \\ &gt; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo File &quot;&#x2F;usr&#x2F;bin&#x2F;yum-config-manager&quot;, line 135 except yum.Errors.RepoError, e: # 修改文件&#x2F;usr&#x2F;bin&#x2F;yum-config-manager，将第一行改为python2 [root@localhost ~]# vim &#x2F;usr&#x2F;bin&#x2F;yum-config-manager #!&#x2F;usr&#x2F;bin&#x2F;python -tt 使用如下命令查看版本： [root@localhost ~]# yum list docker-ce --showduplicates | sort -r [root@localhost ~]# yum list docker-ce-cli --showduplicates | sort -r docker-ce.x86_64 3:20.10.5-3.el7 docker-ce-stable docker-ce.x86_64 3:20.10.4-3.el7 docker-ce-stable docker-ce.x86_64 3:20.10.3-3.el7 docker-ce-stable 安装对应版本的docker（建议安装18.09）: [root@localhost ~]# yum -y install docker-ce-18.09.9 docker-ce-cli-18.09.9 containerd.io # 使用如下命令查看是否安装成功 [root@localhost ~]# docker -v Docker version 18.09.9, build 039a7df9ba 安装可视化界面（可选）# 下载图形界面 yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; # 查看默认启动方式 systemctl get-default # 是multi-user.target # 修改默认启动 systemctl set-default graphical.target # 将默认模式修改为图形界面模式 systemctl set-default multi-user.target # 将默认模式修改为命令行模式 # 使用reboot 命令重启查看 下载fate镜像# 下载安装包： mkdir ~&#x2F;FATE &amp;&amp; cd &amp;&amp; ~&#x2F;FATE wget https:&#x2F;&#x2F;webank-ai-1251170195.cos.ap-guangzhou.myqcloud.com&#x2F;docker_standalone_fate_1.6.0.tar.gz # 解压文件 tar -xzvf docker_standalone_fate_1.6.0.tar.gz # 执行部署 cd docker_standalone_fate_1.6.0 bash install_standalone_docker.sh 如果出现container已经在运行，停止运行再次输入上面的命令即可。 docker ps # 可以查看当前正在运行的容器 docker ps -a # 可以查看所有容器，包括没有运行的。 如果出现端口号8080被占用： # 输入以下命令查看占用端口号的进程 [root@localhost docker_fate]# fuser -v -n tcp 8080 用户 进程号 权限 命令 8080&#x2F;tcp: root 7463 F.... java # 使用kill命令结束进程 kill 7463 测试# 进入docker环境 CONTAINER_ID&#x3D;&#96;docker ps -aqf &quot;name&#x3D;fate&quot;&#96; docker exec -t -i $&#123;CONTAINER_ID&#125; bash # 测试 bash .&#x2F;python&#x2F;federatedml&#x2F;test&#x2F;run_test.sh # 出现下方语句表示成功： there are 0 failed test 安装fate-clientvirtualwrapper命令： mkvirtualenv [virtualname] 创建新的虚拟环境, 并进入 lsvirtualenv 列出所有的虚拟环境 workon [virtualname] 进入或切换虚拟环境 cdvirtualenv 进入当前的虚拟环境的目录 deactivate 退出虚拟环境 创建虚拟环境并安装： mkvirtual fate pip install fate-client","categories":[{"name":"联邦学习","slug":"联邦学习","permalink":"https://chl-git.github.io/categories/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/tags/Linux/"},{"name":"Centos7","slug":"Centos7","permalink":"https://chl-git.github.io/tags/Centos7/"},{"name":"FATE","slug":"FATE","permalink":"https://chl-git.github.io/tags/FATE/"},{"name":"联邦学习","slug":"联邦学习","permalink":"https://chl-git.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"},{"name":"环境配置","slug":"环境配置","permalink":"https://chl-git.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Corda-API-Flows","slug":"Corda-API-Flows","date":"2021-04-08T02:52:15.000Z","updated":"2021-06-15T14:17:22.791Z","comments":true,"path":"posts/aa15b6d6/","link":"","permalink":"https://chl-git.github.io/posts/aa15b6d6/","excerpt":"","text":"Flows一个流程示例包括两个方面： Initiator：发起方 Responder：响应方 发起方包含如下流程： Part1——建立交易 选择公证人 创建交易生成器（transaction builder） 从库中提出所有的输入状态，并添加到生成器中 创建所有输出并添加到生成器中 添加commands，attachments和time-window Part2——签名 对交易生成器签名 将生成器转换为签名过的交易（signed transtraction） Part3——验证交易 通过合同（contracts）验证交易 Part4——收集交易对手的签名 将交易 关闭会话API 在FLowsession中有clolse() 在FlowLogic中有closw(sessions:NonEmpty&lt;FlowSession&gt;) val session = initiateFlow(party) try &#123; ... &#125; finally &#123; session.close() &#125; val session = initiateFlow(party) session.use &#123; ... &#125; 不要在finally语句块中使用close()，有如下两个原因: 没有必要。上面如果报错，流就会终止，状态机会释放资源和内存等，不需要再调用close()。 出现我们不期望的结果。例如：我们本应该收到错误信息，但是由于在finally中添加了close()，我们可能得到的是关闭flow的相关信息，而没有得到期望的错误信息。","categories":[],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"Corda-API","slug":"Corda-API","permalink":"https://chl-git.github.io/tags/Corda-API/"},{"name":"Flow","slug":"Flow","permalink":"https://chl-git.github.io/tags/Flow/"}]},{"title":"Corda（4）——单元测试","slug":"Corda（4）——单元测试","date":"2021-04-05T09:17:35.000Z","updated":"2021-06-15T14:17:47.954Z","comments":true,"path":"posts/b07c1e78/","link":"","permalink":"https://chl-git.github.io/posts/b07c1e78/","excerpt":"","text":"查看链接 @Before在当前测试类中，使用@Before注解的方法会在后面的每一个测试Test前运行，这将简化很多重复代码的编写。 在每一个测试之前都需要先搭建网络(setup())，正如示例代码所示: @Before public void setup() &#123; network = new MockNetwork(new MockNetworkParameters().withCordappsForAllNodes(ImmutableList.of( TestCordapp.findCordapp(\"com.example.contract\"), TestCordapp.findCordapp(\"com.example.flow\")))); a = network.createPartyNode(null); b = network.createPartyNode(null); // For real nodes this happens automatically, but we have to manually register the flow for tests. for (StartedMockNode node : ImmutableList.of(a, b)) &#123; node.registerInitiatedFlow(ExampleFlow.Acceptor.class); &#125; network.runNetwork(); &#125; @After在当前测试类中，使用@After注解的方法会在后面的每一个测试Test后运行，比如测试完成后需要停止节点，关闭网络(tearDown())。 @After public void tearDown() &#123; network.stopNodes(); &#125; Rule@Rule注解是方法级别的，每个测试方法执行时都会执行被@Rule注解的成员变量的方法（类似于@Before）。 这相当于给每个测试方法定义一个规则，比如示例： @Rule public final ExpectedException exception = ExpectedException.none(); 可以这么理解： rule为：如果抛出异常，则抛出异常为ExpectedException.none() 这规则是可以自定义的，可以参考这个链接 @Before注解的方法只能作用于当前测试类及其子类，而实现了TestRule的类可以被用于多个测试类 @ClassRule注解是类级别的，测试类执行时仅会执行一次被@ClassRule注解的静态变量的方法（类似于@BeforeClass）。","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"单元测试","slug":"单元测试","permalink":"https://chl-git.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"注解","slug":"注解","permalink":"https://chl-git.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Corda（3）——节点数据库配置以及访问","slug":"Corda（3）——节点数据库配置以及访问","date":"2021-04-05T01:07:57.000Z","updated":"2021-06-15T14:30:14.656Z","comments":true,"path":"posts/f6070d29/","link":"","permalink":"https://chl-git.github.io/posts/f6070d29/","excerpt":"","text":"下载H2H2下载 配置节点在每个节点的shell中输入bye关闭所有节点。 到workflows-java/build.gradle文件夹中修改配置 nodeDefaults &#123; cordapp project(\":contracts-java\") // 添加一下代码 extraConfig = [ h2Settings: [ // A random port will be selected. address : 'localhost:0' ] ] &#125; 重新部署并运行节点 在每个shell里面会多出类似下面一行代码： Database connection url is : jdbc:h2:tcp:&#x2F;&#x2F;localhost:61433&#x2F;node 启动h2，在页面添加JDBC URL，其他的不用更改(每个节点进行同样的操作) 可以选择语言 创建IOU在PartyA输入一下命令： flow start Initiator iouValue: 50,otherParty:&quot;O&#x3D;PartyB,L&#x3D;New York,C&#x3D;US&quot; 当然可以在PartyB先进行监听（上面已经提到vaultTrack） 在PartyA和PartyB的web控制台上找到并点击VAULT_STATES,然后点击运行，会显示一条记录，在其他的节点查询不到相关信息。 在PartyA和PartyB会多一个IOU_STATES，查询得到如下的信息： 列名在IOUState的schema中定义。 我们知道，一个’state’的唯一性由产生它的transaction和作为输出的列表中的index表示，这个特性在StateRdf class中定义 在h2web控制台中PartyA和PartyB的IOU_STATES可以看到(VAULT_STATES也可以看到)： checkpoints关闭PartyC和Notary，在PartyA中创建和 PartyC的IOU， Mon Apr 05 15:37:24 CST 2021&gt;&gt;&gt; flow start Initiator iouValue: 5,otherParty: &quot;O&#x3D;PartyC,L&#x3D;Paris,C&#x3D;FR&quot; Starting Generating transaction based on new IOU. Verifying contract constraints. Signing transaction with our private key. Gathering the counterparty&#39;s signature. Collecting signatures from counterparties. 会停在colecting signatures from counterparties这里，可以在h2web控制台中查看PartyA的信息，可以看到IOU_STATE没有增加记录，但是在NODE_CHECKPOINTS中有一条记录如下： 重新运行PartyC： &#x2F;&#x2F; 必须先进入workflows-java&#x2F;build&#x2F;nodes&#x2F;PartyC cd workflows-java&#x2F;build&#x2F;nodes&#x2F;PartyC java -jar corda.jar &#x2F;&#x2F;下面这个命令是不行的，提示找不到&#96;node.conf&#96; &#x2F;&#x2F;java -jar workflows-java&#x2F;build&#x2F;nodes&#x2F;PartyC&#x2F;corda.jar more detailsNotary提供交易的唯一性标识，并且避免双花，但是我们上面的创建IOU的过程是不涉及到state的消耗的，所以就算在workflows-java/build.gradle中将Notary的validating,改为true，当不启动Natory时，也会完成上面的流程，或者说上面的transactions是没有输入的，是不需要Notary参与的。 node &#123; name \"O=Notary,L=London,C=GB\" notary = [validating : false] //这里改为true p2pPort 10000 rpcSettings &#123; address(\"localhost:10001\") adminAddress(\"localhost:10002\") &#125; projectCordapp &#123; deploy = false &#125; cordapps.clear() &#125; .jar 注入在每一个节点的文件夹中都有数据cordapps，这是完整整个flow必须的.jar。","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"H2数据库","slug":"H2数据库","permalink":"https://chl-git.github.io/tags/H2%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Corda（2）——示例","slug":"Corda（2）——示例","date":"2021-04-03T13:29:56.000Z","updated":"2021-06-15T14:28:48.703Z","comments":true,"path":"posts/63bb09b4/","link":"","permalink":"https://chl-git.github.io/posts/63bb09b4/","excerpt":"","text":"运行Corda的示例下载源码(java版)cd [your workspace] git clone https://github.com/corda/samples-java.git 在IDE中打开samples-java/Basic/cordapp-examples目录结构如下： ├── LICENCE ├── README.md ├── TRADEMARK ├── build.gradle ├── clients │ ├── build.gradle │ └── src │ └── main │ ├── java │ │ └── net │ │ └── corda │ │ └── samples │ │ └── example │ │ ├── Client.java │ │ └── webserver │ │ ├── Controller.java │ │ ├── NodeRPCConnection.java │ │ └── Starter.java │ └── resources │ └── static │ ├── app.js │ └── index.html ├── config │ ├── dev │ │ └── log4j2.xml │ └── test │ └── log4j2.xml ├── contracts │ ├── build.gradle │ └── src │ ├── main │ │ └── java │ │ └── net │ │ └── corda │ │ └── samples │ │ └── example │ │ ├── contracts │ │ │ └── IOUContract.java │ │ ├── schema │ │ │ ├── IOUSchema.java │ │ │ └── IOUSchemaV1.java │ │ └── states │ │ └── IOUState.java │ └── test │ └── java │ └── net │ └── corda │ └── samples │ └── example │ └── contracts │ ├── ContractTests.java │ └── StateTests.java ├── gradle │ └── wrapper │ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── gradle.properties ├── gradlew ├── gradlew.bat ├── repositories.gradle ├── settings.gradle └── workflows ├── build.gradle └── src ├── integrationTest │ └── java │ └── net │ └── corda │ └── samples │ └── example │ └── DriverBasedTest.java ├── main │ ├── java │ │ └── net │ │ └── corda │ │ └── samples │ │ └── example │ │ └── flows │ │ └── ExampleFlow.java │ └── resources │ └── migration │ ├── iou.changelog-master.xml │ └── iou.changelog-v1.xml └── test └── java └── net └── corda └── samples └── example └── FlowTests.java clients文件夹包含的是用于Spring Boot集成的源码 config是配置文件，包含log4j2 contracts和workflows是CorDapp的源码 gradle是包含Gradle Wrapper 部署节点并运行示例CorDapp打开终端输入一下命令： gradlew.bat deployNodes // tips可以只部署java(或者kotlin) // -b表示 --build-file gradlew.bat -b workflows-java/build.gradle deploynodes 会在根目录下创建文件夹build/nodes，里面会有三个Node文件夹（PartyA,PartyB,Notary），节点信息在根目录下的build.gradle中定义。 输入如下命令运行示例CorDapp call build\\nodes\\runnodes.bat 会打开三个如下的界面，当出现如下图红色方框所示的”welocme”语句时表示成功运行 三种交互方式 通过http 通过交互式shell 通过h2的web控制台 通过http这一部分的内容还要进一步研究 通过交互式shell可以直接在每个节点的shell与节点进行交互，比如在节点A和B之间创建一个IOU（i owe you）账单，在PartyA中输入如下命令： >>>flow start Initiator iouValue: 50, otherParty: \"O=PartyB,L=New York,C=US\" 上面命令中Initiator是一个流（extends FlowLogic），iouValue和otherParty是Initiator中的两个参数。 生产环境中使用Network Map Service来定义节点名字和查找节点，并使用Doorman Service管理准入 得到类似如下结果： 上图中出现如下信息，表示交易完成 Flow completed with result: SignedTransaction(id=AEE179389C8F701C940489BF208D13C09B6E8D48F6AC32979C7F0C2B0BD1B526) 然后可以使用如下命令进行查看： run vaultQuery contractStateType: com.example.state.IOUState 在PartyA和PartyB可以查看类似如下信息，但是Notary是没有的，如果有其他节点也是看不到的，这正是Corda的Need-to-know特性。 contractStateClassName: \"com.example.state.IOUState\" recordedTime: \"2021-04-05T00:05:24.579Z\" consumedTime: null status: \"UNCONSUMED\" notary: \"O=Notary, L=London, C=GB\" 可以看到是UNCONSUMED,com.example.state.IOUState是IOUState的package名。 可以输入以下命令实时查看 在PartyB中输入以下命令： run vaultTrack contractStateType com.example.state.IOUState 当其他节点与B进行交易时，交易信息会在PartyB实时显示。 ...# 省略 totalStatesAvailable: -1 stateTypes: \"UNCONSUMED\" otherResults: [] Updates: Waiting for completion or Ctrl-C ... 通过h2的web控制台","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"}]},{"title":"Git初识","slug":"Git初识","date":"2021-03-29T13:01:17.000Z","updated":"2021-06-15T14:18:11.281Z","comments":true,"path":"posts/89f97af8/","link":"","permalink":"https://chl-git.github.io/posts/89f97af8/","excerpt":"","text":"拉取代码：git pull 推本地代码上去：1、git status2、git add [filename1] [filename2]3、git commit [filename1] -m “提交信息说明”4、git push 回退1、退回至缓存区的coding回退git reset [filename1]2、会退到制定版本git reset –hard 版本号（版本号为commit后的） 看提交日志：git loggit log –oneline 分支1、查看分支git branch2、创建分支git branch 分支名3、切花分支git checkout 分支名git checkout -b 分支名（创建并切换分支）4、合并某分支到当前分支git merge 分支名5、删除分支git branch -d 分支名（强行删除 -D）","categories":[{"name":"Git","slug":"Git","permalink":"https://chl-git.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://chl-git.github.io/tags/Git/"},{"name":"branch","slug":"branch","permalink":"https://chl-git.github.io/tags/branch/"}]},{"title":"Tokens SDK","slug":"Tokens-SDK","date":"2021-03-24T12:22:02.000Z","updated":"2021-06-15T14:19:04.506Z","comments":true,"path":"posts/b3ff0665/","link":"","permalink":"https://chl-git.github.io/posts/b3ff0665/","excerpt":"","text":"概念广义来说，token有如下两个定义： 存托凭证（A depository receipt）：这意味着它是对存在于账本之外的东西的分类账本表示； 本机令牌（A native token）：一个本机令牌，表示该值实际上存在于分类帐中，并且无法将其用于账本之外的东西，因为该东西甚至不存在于分类账之外。 令牌可以是ContractState，LinearState，OwnableState或FungibleAsset之一或组合，带有以下3个命令：Issue，Move和Redeem。 可以根据如下设计流（design flow）为tokens构建框架： TokenTypeTokenType 是固定单位，您发出该单位的标记。它只需要一个标识符（tokenidentifier），例如 RMB，以及小数位数字的个数(fractionDigits)，这些小数位数本质上定义了令牌的最小面值。(如[RMB token-type，0.01]表示人民币的最小面额为分)。 根据上面的Design Flow，TokenType在设计之后使用的整个生命周期是不可变的，但是在设计的时候可以根据需要扩展，添加除前面已经提到的标识符和小数位数之外的其他属性，但是一旦定义在流通及回收的过程中就是不可以变的。 EvovableTokenType与TokenType 实例不同，EvolvableTokenType 实例是一个 LinearState 实例，该实例将随着时间的推移根据相应的规则而演变。此外，还提供了部分流（flows）促进这种转变。 可以考虑一辆车，车的品牌、型号、车的标识码是不变的，但是里程数，价格是会随着时间的推移改变的。","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"SDK","slug":"SDK","permalink":"https://chl-git.github.io/tags/SDK/"},{"name":"token","slug":"token","permalink":"https://chl-git.github.io/tags/token/"},{"name":"fungible","slug":"fungible","permalink":"https://chl-git.github.io/tags/fungible/"},{"name":"non-fungible","slug":"non-fungible","permalink":"https://chl-git.github.io/tags/non-fungible/"}]},{"title":"Corda（1）——基础","slug":"Corda（1）——基础","date":"2021-03-24T05:29:37.000Z","updated":"2021-06-15T14:17:26.876Z","comments":true,"path":"posts/8984fc95/","link":"","permalink":"https://chl-git.github.io/posts/8984fc95/","excerpt":"","text":"区块链基础知识中本聪在2008年10月发表了一片论文，其中指出了数字货币中“双花”问题的解决方案。“比特币”开始收到人们的关注，并且区块链技术被越来越多的人认可，在很多领域找到了适用场景。 在这之前，“双花”是通过可信的第三方机构（最典型的就是银行）对账本进行保管，达到解决问题的目的；而在区块链上，每个参与方都有分类账的副本，如果需要更改记录，需要网络中的节点达成共识，这就可以解决“双花”问题 Corda","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"密码学","slug":"密码学","permalink":"https://chl-git.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"DLT","slug":"DLT","permalink":"https://chl-git.github.io/tags/DLT/"},{"name":"共识","slug":"共识","permalink":"https://chl-git.github.io/tags/%E5%85%B1%E8%AF%86/"}]},{"title":"Vim编辑器","slug":"Vim编辑器","date":"2021-03-17T14:32:03.000Z","updated":"2021-06-15T14:19:08.279Z","comments":true,"path":"posts/73bed3ab/","link":"","permalink":"https://chl-git.github.io/posts/73bed3ab/","excerpt":"VIM编辑器简介Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。","text":"VIM编辑器简介Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 三种使用模式基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 输入模式在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！ 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以可以进行任何的编辑。 按下 ESC 按钮回到一般模式 按下 Esc 这个按钮，输入 :wq 储存后离开 vim！ OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。 Vim 按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等： 移动光标的方法 命令的含义 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) Ctrl + d 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 数字&lt; space&gt; 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！(常用) n&lt; Enter&gt; n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明： 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明： 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/categories/Linux/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://chl-git.github.io/tags/vim/"},{"name":"linux","slug":"linux","permalink":"https://chl-git.github.io/tags/linux/"},{"name":"编辑器","slug":"编辑器","permalink":"https://chl-git.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"Linux常用基本命令","slug":"Linux常用基本命令","date":"2021-03-17T14:25:24.000Z","updated":"2021-06-15T14:18:53.794Z","comments":true,"path":"posts/56783b8/","link":"","permalink":"https://chl-git.github.io/posts/56783b8/","excerpt":"最近在开始接触Linux，这里是一些常用基本命令的总结","text":"走近linux在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 关机指令为：shutdown ； sync # 将数据由内存同步到硬盘中。 shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机： shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机 shutdown –h now # 立马关机 shutdown –h 20:25 # 系统会在今天20:25关机 shutdown –h +10 # 十分钟后关机 shutdown –r now # 系统立马重启 shutdown –r +10 # 系统十分钟后重启 reboot # 就是重启，等同于 shutdown –r now halt # 关闭系统，等同于shutdown –h now 和 poweroff # 最后总结一下，不管是重启系统还是关闭系统，首先要运行 **sync** 命令，把内存中的数据写到磁盘中。 系统目录结构 树状目录结构：（Linux的一切资源都挂载在这个 &quot;/&quot; 根节点下） 登录系统后，在当前命令窗口下输入命令ls，打开如下的目录文件： 以下是对部分目录的解释： /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。(不要动) /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 常用基本命令目录管理 绝对路径和相对路径 最顶级的目录为根目录 **/**。 绝对路径： 由根目录 / 写起，例如：/usr/share/doc 这个目录。 相对路径： 不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！ 处理目录的常用命令 ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ls在Linux系统当中， ls 命令可能是最常被运行的。语法：ls [-al][目录名称] 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) [root@www ~]# ls -al ~ # ~ 表示用户目录。如果是root，就回到/root,如果是某个user1，就回到/home/user1 cdcd是Change Directory的缩写，这是用来变换工作目录的命令。 语法：cd [相对路径或绝对路径] 测试： # 使用 mkdir 命令创建 test 目录 [root@localhost home]# mkdir test [root@localhost home]# ls chl test [root@localhost home]# cd test [root@localhost test]# ls # 回到上一级 # cd .. # 回到根目录 # cd / pwdPrint Working Directory 的缩写， 显示目前所在的目录 语法：pwd [-P]选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。 测试： # 单纯显示出目前的工作目录 [root@localhost test]# pwd /home/test # 如果是链接，要显示真实地址，可以使用 -P参数 [root@localhost bin]# cd /bin [root@localhost bin]# pwd -P /usr/bin mkdirmake directory,创建新目录,可以创建多级，多个 语法：mkdir [-mp] 目录名称 [目录名称[ 目录名称]] 选项与参数： -m ：配置文件的权限！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 测试： # 进入我们用户目录下 [root@localhost /]# cd /home # 创建多层级目录 [root@localhost home]# mkdir test/test2/test3 mkdir: 无法创建目录\"test/test2/test3\": 没有那个文件或目录 # 加了这个 -p 的选项，可以创建多层目录！ [root@localhost home]# mkdir -p test/test2/test3 # 创建权限为 rwx--x--x 的目录。 [root@localhost test]# mkdir -m 711 test1 [root@localhost test]# ls test1 test2 [root@localhost test]# ls -l 总用量 0 drwx--x--x. 2 root root 6 3月 17 20:25 test1 drwxr-xr-x. 3 root root 19 3月 17 20:23 test2 rmdir 删除空的目录 ，删除目录的时候需要把里面的内容先删掉！！！ 语法：rmdir [-p] 目录名称 选项与参数：**-p ：** 连同上一级『空的』目录也一起删除 测试： # 因为尚有内容，所以无法删除！ [root@localhost home]# rmdir test rmdir: 删除 \"test\" 失败: 目录非空 # 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。 [root@localhost home]# rmdir -p test rmdir: 删除 \"test\" 失败: 目录非空 [root@localhost home]# rmdir -p test/test1/test2 注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录！ cp复制文件或目录,经过测试好像不能复制到多个目标路径 语法： cp [-adfilprsu] 来源档(source) 目标档(destination) cp [options] source1 source2 source3 …. directory 选项与参数： -a： 相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -p： 连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -d： 若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -r： 递归持续复制，用於目录的复制行为；(常用) -f： 为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i： 若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l： 进行硬式连结(hard link)的连结档创建，而非复制文件本身。 -s： 复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u： 若 destination 比 source 旧才升级 destination ！ 测试： # 在home下创建两个文件夹test1,test2,test3 [root@localhost home]# mkdir test1 test2 test3 [root@localhost home]# ls test1 test2 test3 # 在test1里创建f1文件 [root@localhost home]# cd test1 [root@localhost test1]# vim f1 # 复制 test1目录下的f1 到 test2,test3目录下 [root@localhost test1]# cd /home [root@localhost home]# cp test1/f1 test2 test3 cp: 略过目录\"test2\" [root@localhost home]# cd test3 [root@localhost test2]# ls f1 # 再次复制，加上-i参数，增加覆盖询问？ [root@localhost home]# cp -i test1/f1 test3 cp：是否覆盖\"test3/f1\"？ y# n不覆盖，y为覆盖 rm移除文件或目录 语法：rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 测试： # 将刚刚在 cp 的实例中创建的 f1删除掉！ [root@localhost home]# rm -i test3/f1 rm：是否删除普通文件 \"test3/f1\"？ # 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！ rm -rf / # 命令解释：强制递归删除根目录`/`下所有文件！！！ mv移动文件与目录，或修改名称 语法： mv [-fiu] source destination mv [options] source1 source2 source3 …. directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 测试： # 将test3下f1文件移动到test2下 [root@localhost home]# mv test3/f1 test2 [root@localhost home]# cd test3 [root@localhost test3]# ls [root@localhost home]# cd test2 [root@localhost test2]# ls f1 #可以使用*表示所有文件，将test2下所有文件移动到test3 [root@localhost test2]# ls f1 f2 [root@localhost home]# mv test2/* test3 [root@localhost home]# cd test2 [root@localhost test2]# ls [root@localhost test2]# cd ../test3 [root@localhost test3]# ls f1 f2 # 若目标文件夹不存在，就相当于重命名！ [root@localhost home]# ls test1 test2 test3 [root@localhost home]# mv test3 test4 [root@localhost home]# ls test1 test2 test4 基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： ​前三个比较常用 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定，例如： 文件类型 属主 属组 其他用户 d rwx r-x r-x 其中： 第1、4、7位用字符”r”，表示有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 修改文件属性 1、chgrp：更改文件属组: 语法： chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组: 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 3、chmod：更改文件9个属性（必须掌握）: 语法： chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 # chmod 777 [filename] 所有用户可读可写可执行（rwxrwxrwx） 文件内容查看可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat 由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： 可以同时查看多个文件 [root@localhost home]# cat test1/f1 test4/f1 begin end begin end tactac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： [root@localhost home]# tac test1/f1 end begin nl 显示行号 语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： [root@localhost home]# nl -n ln test1/f1 1 begin 2 end [root@localhost home]# nl -n rn test1/f1 1 begin 2 end [root@localhost home]# nl -n rz test1/f1 000001 begin 000002 end more在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter：代表向下翻『一行』； /字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 [root@localhost home]# more /etc/csh.login ....(省略).... --More--(61%) # 重点在这一行喔！你的光标也会在这里等待你的命令 lessless运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； [root@localhost home]# more /etc/csh.login ....(中间省略).... : # 这里可以等待你输入命令！ head语法： head [-n number] 文件 选项与参数：**-n** 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： [root@localhost home]# head -n 20 /etc/csh.login tail语法： tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： [root@localhost home]# tail -n 20 /etc/csh.login ifconfig 可以查看网络情况： # 安装ifconfig命令： yum search ifconfig yum install net-tools.x86_64","categories":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://chl-git.github.io/tags/linux/"},{"name":"命令","slug":"命令","permalink":"https://chl-git.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"Corda-API--Contarcts","slug":"Corda-API--Contracts","date":"2021-03-13T14:59:33.567Z","updated":"2021-06-15T14:17:17.436Z","comments":true,"path":"posts/153d6957/","link":"","permalink":"https://chl-git.github.io/posts/153d6957/","excerpt":"对于Corda，需要熟悉的API的使用才能在处理业务逻辑的时候利用好平台的接口编写正确的代码。 Contractscontracts都是implement于接口contracts，这个接口只有一个verify方法，输入是一个LedgerTransaction的实例。","text":"对于Corda，需要熟悉的API的使用才能在处理业务逻辑的时候利用好平台的接口编写正确的代码。 Contractscontracts都是implement于接口contracts，这个接口只有一个verify方法，输入是一个LedgerTransaction的实例。 使用kotlin语言定义如下/** * Implemented by a program that implements business logic on the shared ledger. All participants run this code for * every [net.corda.core.transactions.LedgerTransaction] they see on the network, for every input and output state. All * contracts must accept the transaction for it to be accepted: failure of any aborts the entire thing. The time is taken * from a trusted time-window attached to the transaction itself i.e. it is NOT necessarily the current time. * * TODO: Contract serialization is likely to change, so the annotation is likely temporary. */ @KeepForDJVM @CordaSerializable interface Contract &#123; /** * Takes an object that represents a state transition, and ensures the inputs/outputs/commands make sense. * Must throw an exception if there's a problem that should prevent state transition. Takes a single object * rather than an argument so that additional data can be added without breaking binary compatibility with * existing contract code. */ @Throws(IllegalArgumentException::class) fun verify(tx: LedgerTransaction) &#125; verify方法通过以下三步判断交易是否合法： 收集每一个交易的输入和输出states 将交易tx作为输入传入verify函数 只有全部通过才能在数据中进行 verify函数在沙盒执行，在验证交易tx的合法性时只能访问定义在LedgerTransaction里面的属性。 在每一个constract中必须重写verify方法： @override public void verify(LeadgerTransaction tx)&#123; // 1.什么都不写表示全部通过 // Always accepts！ // 2.只写下面表示全部拒绝 throw new IllegalArgumentException('Always rejects!'); &#125; LedgerTransaction","categories":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"}],"tags":[{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"区块链","slug":"区块链","permalink":"https://chl-git.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Corda-API","slug":"Corda-API","permalink":"https://chl-git.github.io/tags/Corda-API/"},{"name":"Contract","slug":"Contract","permalink":"https://chl-git.github.io/tags/Contract/"}]},{"title":"Linux-learning","slug":"Linux-learning","date":"2021-03-13T13:24:55.000Z","updated":"2021-06-15T14:18:49.839Z","comments":true,"path":"posts/41805539/","link":"","permalink":"https://chl-git.github.io/posts/41805539/","excerpt":"Linux 链接概念Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 可以使用ln 命令产生硬链接。","text":"Linux 链接概念Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 可以使用ln 命令产生硬链接。 硬连接: 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接: 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： [root@kuangshen /]# cd /home [root@kuangshen home]# touch f1 # 创建一个测试文件f1 [root@kuangshen home]# ls f1 [root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2 [root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3 [root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息 397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1 397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2 397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -> f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 # echo 字符串输出 >> f1 输出到 f1文件 [root@kuangshen home]# echo \"I am f1 file\" >>f1 [root@kuangshen home]# cat f1 I am f1 file [root@kuangshen home]# cat f2 I am f1 file [root@kuangshen home]# cat f3 I am f1 file [root@kuangshen home]# rm -f f1 [root@kuangshen home]# cat f2 I am f1 file [root@kuangshen home]# cat f3 cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3，对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 账号管理 简介 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 用户账号的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录bash等资源。 添加账号 useradd useradd 选项 用户名 参数说明： 选项 : -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -m 使用者目录如不存在则自动建立。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 测试： # 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 &#x2F;home&#x2F;kuangshen [root@kuangshen home]# useradd -m kuangshen 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 Linux下如何切换用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 删除帐号 如果一个用户的账号不再使用，可以从系统中删除。 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用userdel命令，其格式如下： userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 [root@kuangshen home]# userdel -r kuangshen 此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 修改帐号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer kuangshen 此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。 命令的格式为： passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令： $ passwd Old password:****** New password:******* Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： # passwd kuangshen New password:******* Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： # passwd -d kuangshen 此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： # passwd -l kuangshen 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 增加一个新的用户组使用groupadd命令 groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 实例1： # groupadd group1 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 实例2： # groupadd -g 101 group2 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 如果要删除一个已有的用户组，使用groupdel命令 groupdel 用户组 例如： # groupdel group1 此命令从系统中删除组group1。 修改用户组的属性使用groupmod命令 groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 # 此命令将组group2的组标识号修改为102。 groupmod -g 102 group2 # 将组group2的标识号改为10000，组名修改为group3。 groupmod –g 10000 -n group3 group2 切换组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。 /etc/passwd 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。 下面分别介绍这些文件的内容。 /etc/passwd文件是用户管理工作涉及的最重要的一个文件。 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 这个文件对所有用户都是可读的。它的内容类似下面的例子： ＃ cat &#x2F;etc&#x2F;passwd root:x:0:0:Superuser:&#x2F;: daemon:x:1:1:System daemons:&#x2F;etc: bin:x:2:2:Owner of system commands:&#x2F;bin: sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys: adm:x:4:4:System accounting:&#x2F;usr&#x2F;adm: uucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp: auth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth: cron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron: listen:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls: lp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp: 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令（密码）:用户标识号:组标识号:注释性描述:主目录:登录Shell 1）”用户名”是代表用户账号的字符串。 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 2）“口令”一些系统中，存放着加密后的用户口令字。 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 3）“用户标识号”是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 4）“组标识号”字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 5)“注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。 6)“主目录”，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 8)系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪 用 户 含 义 bin 拥有可执行的用户命令文件 sys 拥有系统文件 adm 拥有帐户文件 uucp UUCP使用 lp lp或lpd子系统使用 nobody NFS使用 /etc/shadow 1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。 2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号 “口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 “最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 “最小时间间隔”指的是两次修改口令之间所需的最小天数。 “最大时间间隔”指的是口令保持有效的最大天数。 “警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 “不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。 “失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 /etc/group 用户组的所有信息都存放在/etc/group文件中。 将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。 每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。 用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 “口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 “组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。 “组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 磁盘管理 概述 Linux磁盘管理好坏直接关系到整个系统的性能问题。 Linux磁盘管理常用命令为 df、du。 df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 df df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法： df [-ahikHTm] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 测试： # 将系统内所有的文件系统列出来！ # 在 Linux 底下如果 df 没有加任何选项 # 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！ [root@kuangshen /]# df Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 889100 0 889100 0% /dev tmpfs 899460 704 898756 1% /dev/shm tmpfs 899460 496 898964 1% /run tmpfs 899460 0 899460 0% /sys/fs/cgroup /dev/vda1 41152812 6586736 32662368 17% / tmpfs 179896 0 179896 0% /run/user/0 # 将容量结果以易读的容量格式显示出来 [root@kuangshen /]# df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 869M 0 869M 0% /dev tmpfs 879M 708K 878M 1% /dev/shm tmpfs 879M 496K 878M 1% /run tmpfs 879M 0 879M 0% /sys/fs/cgroup /dev/vda1 40G 6.3G 32G 17% / tmpfs 176M 0 176M 0% /run/user/0 # 将系统内的所有特殊文件格式及名称都列出来 [root@kuangshen /]# df -aT Filesystem Type 1K-blocks Used Available Use% Mounted on sysfs sysfs 0 0 0 - /sys proc proc 0 0 0 - /proc devtmpfs devtmpfs 889100 0 889100 0% /dev securityfs securityfs 0 0 0 - /sys/kernel/security tmpfs tmpfs 899460 708 898752 1% /dev/shm devpts devpts 0 0 0 - /dev/pts tmpfs tmpfs 899460 496 898964 1% /run tmpfs tmpfs 899460 0 899460 0% /sys/fs/cgroup cgroup cgroup 0 0 0 - /sys/fs/cgroup/systemd pstore pstore 0 0 0 - /sys/fs/pstore cgroup cgroup 0 0 0 - /sys/fs/cgroup/freezer cgroup cgroup 0 0 0 - /sys/fs/cgroup/cpuset cgroup cgroup 0 0 0 - /sys/fs/cgroup/hugetlb cgroup cgroup 0 0 0 - /sys/fs/cgroup/blkio cgroup cgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_prio cgroup cgroup 0 0 0 - /sys/fs/cgroup/memory cgroup cgroup 0 0 0 - /sys/fs/cgroup/pids cgroup cgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacct cgroup cgroup 0 0 0 - /sys/fs/cgroup/devices cgroup cgroup 0 0 0 - /sys/fs/cgroup/perf_event configfs configfs 0 0 0 - /sys/kernel/config /dev/vda1 ext4 41152812 6586748 32662356 17% / systemd-1 - - - - - /proc/sys/fs/binfmt_misc mqueue mqueue 0 0 0 - /dev/mqueue debugfs debugfs 0 0 0 - /sys/kernel/debug hugetlbfs hugetlbfs 0 0 0 - /dev/hugepages tmpfs tmpfs 179896 0 179896 0% /run/user/0 binfmt_misc binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc # 将 /etc 底下的可用的磁盘容量以易读的容量格式显示 [root@kuangshen /]# df -h /etc Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 6.3G 32G 17% / du Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。 语法： du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 测试： # 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）: # 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。 [root@kuangshen home]# du 16./redis 8./www/.oracle_jre_usage # 包括隐藏文件的目录 24./www 48. # 这个目录(.)所占用的总量 # 将文件的容量也列出来 [root@kuangshen home]# du -a 4./redis/.bash_profile 4./redis/.bash_logout ....中间省略.... 4./kuangstudy.txt # 有文件的列表了 48. # 检查根目录底下每个目录所占用的容量 [root@kuangshen home]# du -sm /* 0/bin 146/boot .....中间省略.... 0/proc .....中间省略.... 1/tmp 3026/usr # 系统初期最大就是他了啦！ 513/var 通配符 * 来代表每个目录。 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。 磁盘挂载与卸除 根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令。 磁盘挂载语法： mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 测试： # 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！ [root@www ~]# mkdir /mnt/hdc6 [root@www ~]# mount /dev/hdc6 /mnt/hdc6 [root@www ~]# df Filesystem 1K-blocks Used Available Use% Mounted on /dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。 卸载/dev/hdc6 进程管理linux中一切皆文件 命令 ps ：查看当前系统中正在执行的各种进程的信息！ ps -xx： -a 显示当前终端运行的所有进程的信息 -u 以用户的信息显示进程 -x 显示后台运行进程的参数！ ps -aux # 查看所有进程信息 # | 在Linux中叫做管道符 # grep 查找文件中符合条件的字符串 ps -aux|grep mysql ps -aux|grep redis ps -ef :可以查看父进程的信息：ps -ef 进程树：pstree -p 显示父ID -u 显示用户组 pstree -pu # 若命令不存在使用yum install psmisc 命令安装插件 结束进程：一般不使用，特殊情况：如Java程序进入死循环等等。 kill -9 [ID号] 环境安装三种方式： rpm 解压缩 yum在线安装 jdk安装（rpm安装）1、rpm下载地址http://www.oracle.com/technetwork/java/javase/downloads/index.html 2、如果有安装openjdk 则卸载 [root@kuangshen ~]# java -version java version &quot;1.8.0_121&quot; Java(TM) SE Runtime Environment (build 1.8.0_121-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode) # 检查 [root@kuangshen ~]# rpm -qa|grep jdk jdk1.8.0_121-1.8.0_121-fcs.x86_64 # 卸载 -e --nodeps 强制删除 [root@kuangshen ~]# rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64 [root@kuangshen ~]# java -version -bash: &#x2F;usr&#x2F;bin&#x2F;java: No such file or directory # OK 3、安装JDK # 安装java rpm [root@kuangshen kuangshen]# rpm -ivh jdk-8u221-linux-x64.rpm # 安装完成后配置环境变量 文件：&#x2F;etc&#x2F;profile JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_221-amd64 CLASSPATH&#x3D;%JAVA_HOME%&#x2F;lib:%JAVA_HOME%&#x2F;jre&#x2F;lib PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JAVA_HOME&#x2F;jre&#x2F;bin export PATH CLASSPATH JAVA_HOME # 保存退出 # 让新增的环境变量生效！ source &#x2F;etc&#x2F;profile # 测试 java -version [root@kuangshen java]# java -version java version &quot;1.8.0_221&quot; Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) Tomcat安装（解压缩安装）1、安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 2、将文件移动到/usr/tomcat/下，并解压！ [root@kuangshen kuangshen]# mv apache-tomcat-9.0.22.tar.gz &#x2F;usr [root@kuangshen kuangshen]# cd &#x2F;usr [root@kuangshen usr]# ls apache-tomcat-9.0.22.tar.gz [root@kuangshen usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz # 解压 3、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 # 执行：startup.sh --&gt;启动tomcat # 执行：shutdown.sh --&gt;关闭tomcat .&#x2F;startup.sh .&#x2F;shutdown.sh 4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port&#x3D;80&#x2F;tcp #添加端口，格式为：端口&#x2F;通讯协议 --permanent #永久生效，没有此参数重启后失效 安装Docker（yum安装） 基于 CentOS 7 安装 官网安装参考手册：https://docs.docker.com/install/linux/docker-ce/centos/ 确定你是CentOS7及以上版本 [root@192 Desktop]# cat &#x2F;etc&#x2F;redhat-release CentOS Linux release 7.2.1511 (Core) yum安装gcc相关（需要确保 虚拟机可以上外网 ） yum -y install gcc yum -y install gcc-c++ 卸载旧版本 yum -y remove docker docker-common docker-selinux docker-engine # 官网版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 设置stable镜像仓库 # 错误 yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 正确推荐使用国内的 yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo 更新yum软件包索引 yum makecache fast 安装Docker CE yum -y install docker-ce docker-ce-cli containerd.io 启动docker systemctl start docker 测试 docker version docker run hello-world docker images VMware使用快照类似存档 网络配置linux必须配置到本机的对应网段；","categories":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/tags/Linux/"},{"name":"软链接","slug":"软链接","permalink":"https://chl-git.github.io/tags/%E8%BD%AF%E9%93%BE%E6%8E%A5/"},{"name":"硬链接","slug":"硬链接","permalink":"https://chl-git.github.io/tags/%E7%A1%AC%E9%93%BE%E6%8E%A5/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2021-03-12T14:19:07.790Z","updated":"2021-06-15T14:18:58.618Z","comments":true,"path":"posts/3c50d03d/","link":"","permalink":"https://chl-git.github.io/posts/3c50d03d/","excerpt":"","text":"部分markdown语法的学习 目录输入[toc]，然后按enter键将创建一个“目录”部分，从一个人的写作中提取所有标题，其内容将自动更新。 [toc] 标题：## 一级标题 ## 二级标题 # 最多到六级 斜体：*/_斜体斜体 粗体：**/__粗体粗体 删除线：~~删除线 引用：&gt; 引用 分割线：—/*** or 下划线:&lt;u&gt;&lt;/u&gt;下划线 脚注:[^要注释的文本]上文[^脚注]下文 图片：![名字](路径(可以是网址)) 数学表达式要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令，例如：$lim_&#123;x \\to \\infty&#125; \\ exp(-x)=0$将产生如下的数学表达式： $lim_{x \\to \\infty} \\ exp(-x)=0$ $$ f(x)&#x3D;\\int_&#123;2&#125;^&#123;+\\infty&#125; \\frac&#123;dx&#125;&#123;x\\cdot \\sqrt[3]&#123;x^2-3x+2&#125;&#125; $$ $$f(x)=\\int_{2}^{+\\infty} \\frac{dx}{x\\cdot \\sqrt[3]{x^2-3x+2}}$$ $$\\begin{cases} y’’ &amp;=f(x,y,y’) \\ y|{x=x_0}&amp;=y_0 \\ y’|{x=x_0}&amp;=y’_0\\end{cases}$$ 下标下标使用~包裹，例如：H~2~O将产生水的分子式。 H2o 上标上标使用^包裹，例如：y^2^=4将产生表达式 y^2^=4 插入表情使用:happy:输入高兴的表情，使用:sad:输入悲伤的表情，使用:cry:输入哭的表情等。以此类推！ :happy: 代码块 : print` ~~~/``` 表格输入|第一个标题|第二个标题|然后按下enter键讲话创建一个有两列的表格。 创建表之后，在该表上将弹出一个表的工具栏，您可以在其中调整大小，对齐或删除表。 还可以使用上下文菜单来复制和添加/删除列/行。 表格中可以使用链接、粗体、斜体、或删除线等格式。 最后，通过冒号：在标题行中，可以定义文本对齐方式，最左侧的买好表示左对齐，最右侧的冒号表示右对齐，两侧都有冒号表示中心对齐。 | Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is | some wordy text | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Left-Aligned Center Aligned Aligned col 3 some wordy text $1600 col 2 is centered $12 zebra are neat $1 链接：&lt;&gt;参考链接：https://www.jianshu.com/p/b30955885e6d","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://chl-git.github.io/categories/Markdown/"}],"tags":[{"name":"MD","slug":"MD","permalink":"https://chl-git.github.io/tags/MD/"},{"name":"Markdown","slug":"Markdown","permalink":"https://chl-git.github.io/tags/Markdown/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://chl-git.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"hexo","slug":"hexo","permalink":"https://chl-git.github.io/categories/hexo/"},{"name":"java","slug":"java","permalink":"https://chl-git.github.io/categories/java/"},{"name":"Gradle","slug":"Gradle","permalink":"https://chl-git.github.io/categories/Gradle/"},{"name":"Groovy","slug":"Groovy","permalink":"https://chl-git.github.io/categories/Groovy/"},{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/categories/Corda/"},{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/categories/Linux/"},{"name":"联邦学习","slug":"联邦学习","permalink":"https://chl-git.github.io/categories/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Git","slug":"Git","permalink":"https://chl-git.github.io/categories/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://chl-git.github.io/categories/Markdown/"}],"tags":[{"name":"python","slug":"python","permalink":"https://chl-git.github.io/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://chl-git.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://chl-git.github.io/tags/leetcode/"},{"name":"hexo","slug":"hexo","permalink":"https://chl-git.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://chl-git.github.io/tags/markdown/"},{"name":"java","slug":"java","permalink":"https://chl-git.github.io/tags/java/"},{"name":"javaSE","slug":"javaSE","permalink":"https://chl-git.github.io/tags/javaSE/"},{"name":"gradle","slug":"gradle","permalink":"https://chl-git.github.io/tags/gradle/"},{"name":"依赖管理","slug":"依赖管理","permalink":"https://chl-git.github.io/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"Groovy","slug":"Groovy","permalink":"https://chl-git.github.io/tags/Groovy/"},{"name":"Corda","slug":"Corda","permalink":"https://chl-git.github.io/tags/Corda/"},{"name":"Accouts","slug":"Accouts","permalink":"https://chl-git.github.io/tags/Accouts/"},{"name":"UTXO模型","slug":"UTXO模型","permalink":"https://chl-git.github.io/tags/UTXO%E6%A8%A1%E5%9E%8B/"},{"name":"Linux","slug":"Linux","permalink":"https://chl-git.github.io/tags/Linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://chl-git.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"网络配置","slug":"网络配置","permalink":"https://chl-git.github.io/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"name":"防火墙","slug":"防火墙","permalink":"https://chl-git.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"Centos7","slug":"Centos7","permalink":"https://chl-git.github.io/tags/Centos7/"},{"name":"FATE","slug":"FATE","permalink":"https://chl-git.github.io/tags/FATE/"},{"name":"联邦学习","slug":"联邦学习","permalink":"https://chl-git.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"},{"name":"环境配置","slug":"环境配置","permalink":"https://chl-git.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Corda-API","slug":"Corda-API","permalink":"https://chl-git.github.io/tags/Corda-API/"},{"name":"Flow","slug":"Flow","permalink":"https://chl-git.github.io/tags/Flow/"},{"name":"单元测试","slug":"单元测试","permalink":"https://chl-git.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"注解","slug":"注解","permalink":"https://chl-git.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"H2数据库","slug":"H2数据库","permalink":"https://chl-git.github.io/tags/H2%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Git","slug":"Git","permalink":"https://chl-git.github.io/tags/Git/"},{"name":"branch","slug":"branch","permalink":"https://chl-git.github.io/tags/branch/"},{"name":"SDK","slug":"SDK","permalink":"https://chl-git.github.io/tags/SDK/"},{"name":"token","slug":"token","permalink":"https://chl-git.github.io/tags/token/"},{"name":"fungible","slug":"fungible","permalink":"https://chl-git.github.io/tags/fungible/"},{"name":"non-fungible","slug":"non-fungible","permalink":"https://chl-git.github.io/tags/non-fungible/"},{"name":"密码学","slug":"密码学","permalink":"https://chl-git.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"DLT","slug":"DLT","permalink":"https://chl-git.github.io/tags/DLT/"},{"name":"共识","slug":"共识","permalink":"https://chl-git.github.io/tags/%E5%85%B1%E8%AF%86/"},{"name":"vim","slug":"vim","permalink":"https://chl-git.github.io/tags/vim/"},{"name":"linux","slug":"linux","permalink":"https://chl-git.github.io/tags/linux/"},{"name":"编辑器","slug":"编辑器","permalink":"https://chl-git.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"命令","slug":"命令","permalink":"https://chl-git.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"区块链","slug":"区块链","permalink":"https://chl-git.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Contract","slug":"Contract","permalink":"https://chl-git.github.io/tags/Contract/"},{"name":"软链接","slug":"软链接","permalink":"https://chl-git.github.io/tags/%E8%BD%AF%E9%93%BE%E6%8E%A5/"},{"name":"硬链接","slug":"硬链接","permalink":"https://chl-git.github.io/tags/%E7%A1%AC%E9%93%BE%E6%8E%A5/"},{"name":"MD","slug":"MD","permalink":"https://chl-git.github.io/tags/MD/"},{"name":"Markdown","slug":"Markdown","permalink":"https://chl-git.github.io/tags/Markdown/"}]}